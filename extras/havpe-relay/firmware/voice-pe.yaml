#!/usr/bin/env esphome
# Voice PE ESPHome Configuration for XMOS-Enhanced Audio Streaming
# This configuration accesses the XMOS XU316 processed audio with beamforming,
# noise suppression, and echo cancellation for optimal transcription quality.

substitutions:
  device_name: voice-pe-tcp-stream
  friendly_name: Voice PE XMOS Audio Streamer
  wifi_ssid: !secret wifi_ssid
  wifi_password: !secret wifi_password
  server_ip: !secret relay_ip_address
  server_port: "8989"

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  includes:
    - tcp_stream.h
  platformio_options:
    build_flags:
      - -DCONFIG_ARDUHAL_LOG_DEFAULT_LEVEL=5
  on_boot:
    priority: 600
    then:
      # Purple LED during boot
      - logger.log:
          tag: "LED"
          level: INFO
          format: "Setting LED to purple (boot/startup)"
      - light.turn_on:
          id: status_led
          brightness: 30%
          red: 50%
          green: 0%
          blue: 100%

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf
    version: recommended

# Use the official Voice PE external components
external_components:
  - source:
      type: git
      url: https://github.com/esphome/home-assistant-voice-pe
      ref: dev
    components:
      - voice_kit
    refresh: 0s

logger:
  level: INFO
  baud_rate: 115200

wifi:
  ssid: ${wifi_ssid}
  password: ${wifi_password}
  
  # Enhanced connection settings for stable audio streaming
  power_save_mode: none
  fast_connect: true
  reboot_timeout: 15min
  
  # Start XMOS audio streaming when WiFi connects
  on_connect:
    then:
      - logger.log:
          tag: tcp
          level: INFO
          format: "Wi-Fi connected â€“ starting XMOS-enhanced audio capture"
      - microphone.capture: i2s_mics
      # Set LED to orange while waiting for TCP connection
      - logger.log:
          tag: "LED"
          level: INFO
          format: "Setting LED to orange (WiFi connected, waiting for TCP)"
      - light.turn_on:
          id: status_led
          brightness: 50%
          red: 100%
          green: 50%
          blue: 0%

# api:
#   encryption:
#     key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

# Global variables for tracking state
globals:
  - id: tcp_connected
    type: bool
    initial_value: 'false'
  - id: connection_retry_count
    type: int
    initial_value: '0'

# Voice Kit component for XMOS coordination
voice_kit:
  id: voice_kit_component
  i2c_id: internal_i2c
  reset_pin: GPIO4
  firmware:
    url: https://github.com/esphome/voice-kit-xmos-firmware/releases/download/v1.3.1/ffva_v1.3.1_upgrade.bin
    version: "1.3.1"
    md5: 964635c5bf125529dab14a2472a15401

# I2C for Voice Kit communication
i2c:
  - id: internal_i2c
    sda: GPIO18
    scl: GPIO8
    frequency: 100khz

# I2S Audio setup for Voice PE hardware
i2s_audio:
  - id: i2s_input
    i2s_lrclk_pin: GPIO14  # Word Select (Frame Sync)
    i2s_bclk_pin: GPIO13   # Bit Clock

# Voice kit handles the AIC3204 DAC internally

# XMOS-Enhanced Microphone Configuration  
# This accesses the XMOS XU316 processed audio with:
# - Dual microphone beamforming
# - Hardware noise suppression
# - Echo cancellation  
# - Automatic gain control
microphone:
  - platform: i2s_audio
    id: i2s_mics
    i2s_din_pin: GPIO15
    adc_type: external
    pdm: false
    sample_rate: 16000           # Voice PE standard rate
    bits_per_sample: 32bit       # 32-bit I2S containers
    i2s_mode: secondary
    i2s_audio_id: i2s_input
    channel: stereo
    
    # Enhanced audio streaming via TCP
    on_data:
      then:
        - lambda: |-
            static int sockfd = -1;
            static bool connected = false;
            static bool announced = false;
            static unsigned long last_retry_time = 0;
            const unsigned long retry_delay = 5000; // 5 seconds between retries
            
            // Enhanced XMOS audio metadata
            ESP_LOGV("xmos_audio", "XMOS buffer: %d bytes, rate: 48kHz, bits: 32", (int)x.size());
            
            // (Re)establish TCP connection if needed
            if (sockfd < 0) {
              unsigned long current_time = millis();
              
              // Rate limit connection attempts
              if (current_time - last_retry_time < retry_delay) {
                return;
              }
              last_retry_time = current_time;
              
              // Update LED to red pulse when retrying
              if (id(connection_retry_count) > 0) {
                ESP_LOGI("LED", "Setting LED to red pulse (retry %d)", id(connection_retry_count));
                auto call = id(status_led).turn_on();
                call.set_brightness(1.0);
                call.set_rgb(1.0, 0.0, 0.0); // Red
                call.set_effect("Retry Pulse");
                call.perform();
              }
              
              sockfd = lwip_socket(AF_INET, SOCK_STREAM, 0);
              if (sockfd >= 0) {
                // Set socket options for real-time audio streaming
                int nodelay = 1;
                lwip_setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &nodelay, sizeof(nodelay));
                
                struct sockaddr_in dest {};
                dest.sin_family = AF_INET;
                dest.sin_port = htons(atoi("${server_port}"));
                inet_pton(AF_INET, "${server_ip}", &dest.sin_addr);
                
                int result = lwip_connect(sockfd, (struct sockaddr *)&dest, sizeof(dest));
                if (result == 0) {
                  connected = true;
                  id(tcp_connected) = true;
                  id(connection_retry_count) = 0;
                  ESP_LOGI("tcp_xmos", "Connected to XMOS audio relay at %s:%s", 
                           "${server_ip}", "${server_port}");
                  
                  // Update LED to solid blue when connected
                  ESP_LOGI("LED", "Setting LED to solid blue (connected and streaming)");
                  auto call = id(status_led).turn_on();
                  call.set_brightness(0.5);
                  call.set_rgb(0.0, 0.0, 1.0); // Blue
                  call.set_effect("none");
                  call.perform();
                } else {
                  ESP_LOGE("tcp_xmos", "Failed to connect: errno=%d", errno);
                  lwip_close(sockfd);
                  sockfd = -1;
                  connected = false;
                  id(tcp_connected) = false;
                  id(connection_retry_count) += 1;
                }
              } else {
                ESP_LOGE("tcp_xmos", "Socket creation failed: errno=%d", errno);
                id(connection_retry_count) += 1;
              }
            }
            
            // Stream XMOS-enhanced audio data
            if (sockfd >= 0 && connected) {
              ssize_t bytes_sent = lwip_send(sockfd, x.data(), x.size(), 0);
              if (bytes_sent < 0) {
                ESP_LOGE("tcp_xmos", "Send failed: errno=%d - reconnecting", errno);
                lwip_close(sockfd);
                sockfd = -1;
                connected = false;
                announced = false;
                id(tcp_connected) = false;
                id(connection_retry_count) += 1;
              } else if (!announced) {
                ESP_LOGI("tcp_xmos", "Streaming XMOS-enhanced audio (48kHz/32bit/stereo beamformed)");
                announced = true;
              }
              ESP_LOGV("tcp_xmos", "Sent %d/%d bytes", (int)bytes_sent, (int)x.size());
            }

# LED Power Supply
power_supply:
  - id: led_power
    pin: GPIO45

# Status LED for connection state (full 12-LED ring)
light:
  - platform: esp32_rmt_led_strip
    id: status_led
    name: "Status LED"
    pin: GPIO21
    chipset: WS2812
    num_leds: 12
    rgb_order: GRB
    default_transition_length: 0ms
    power_supply: led_power
    effects:
      # Slow pulse effect for retrying
      - pulse:
          name: "Retry Pulse"
          transition_length: 1s
          update_interval: 2s

# Network diagnostics
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "IP Address"
    ssid:
      name: "Connected SSID"
    mac_address:
      name: "Mac Address"

sensor:
  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s
    
  - platform: uptime
    name: "Uptime"
    update_interval: 60s

# Physical center button for reset
binary_sensor:
  - platform: gpio
    id: center_button
    pin:
      number: GPIO0
      inverted: true
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - logger.log:
          tag: "BUTTON"
          level: INFO
          format: "Center button pressed"
    on_multi_click:
      # Long press for restart (hold for 5 seconds)
      - timing:
          - ON for at least 5s
        then:
          - logger.log:
              tag: "BUTTON"
              level: INFO
              format: "Long press detected - restarting device"
          - button.press: restart_button

# Restart button for remote management  
button:
  - platform: restart
    id: restart_button
    name: "Restart"